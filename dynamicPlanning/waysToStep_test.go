package dynamicPlanning

import "fmt"

/*

面试题 08.01. 三步问题
三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。
实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

 输入：n = 3
 输出：4
 说明: 有四种走法


示例2:

 输入：n = 5
 输出：13
提示:

n范围在[1, 1000000]之间
*/

func waysToStep(n int) int {
	if n == 1 {
		return 1
	}
	if n == 2 {
		return 2
	}
	if n == 3 {
		return 4
	}

	dp := make([]int, n+1)
	dp[1] = 1
	dp[2] = 2
	dp[3] = 4

	for i := 4; i <= n; i++ {
		dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007
	}
	return dp[n]

	//数组只用了滚动的四个值，可以用四个变量进行空间优化
	//a, b, c, d := 1, 2, 4, 0
	//	//for i := 3; i < n; i++ {
	//	//	d = (a + b + c) % 1000000007
	//	//	a = b % 1000000007
	//	//	b = c % 1000000007
	//	//	c = d
	//	//}
	//	//return d
}

//思路一 Fibonacci数列
//问题为求解跨到第n级台阶的方式有多少种(dp[n])?
//子问题就是求解跨到第i级台阶第方式有多少种(dp[i])？1<=i<=n
//讲子问题转化为对第i级台阶第决策，即如何到达第i级台阶？跨一级台阶到/跨两级台阶到/跨三级台阶到：
//跨一级台阶到第i级台阶带来到方式有dp[i-1]种；
//跨两级台阶到第i级台阶带来到方式有dp[i-2]种；
//跨三级台阶到第i级台阶带来到方式有dp[i-3]种；
//所以，dp[i]=dp[i-1]+dp[i-2]+dp[i-3] //Fibonacci数列F(n)=F(n-1)+F(n-2)
//采用自底向上的方法实现。
//
//时间负责度O(n),空间复杂度O(n),可以优化到O(1)
//
//
//思路二 需要装满的完全背包问题
//此题还可以理解为需要装满的完全背包问题，1阶/2阶/3阶可以看成3种物品，背包容量为n阶

/*
确定状态
假设有n阶台阶
设n阶台阶的走法有f(n)种
如果最后一步走1步：则前面的走法共有 f(n-1) 种
如果最后一步走2步：则前面的走法共有  f(n-2) 种
如果最后一步走3步：则前面的走法共有  f(n-3) 种

所以走n阶台阶总共有f(n-1)+f(n-2)+f(n-3)种走法

转移方程
f(n) = f(n-1)+f(n-2)+f(n-3)

初始值和边界条件
f(0) = 0
f(1) = 1
f(2) = 2
n >= 3

计算顺序
f(1) + f(2) + f(3) + ... f(n)
*/

func waysToStep2(n int) int {
	dp := make([]int, n+1)
	if n == 0 {
		return 1
	} else if n < 3 {
		return n
	}
	dp[0] = 1
	dp[1] = 1
	dp[2] = 2

	for i := 3; i <= n; i++ {
		dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007
	}

	return dp[n]
}

func ExampleWaysToStep() {
	fmt.Println(waysToStep(3))
	fmt.Println(waysToStep(5))
	//Output:
	//4
	//13
}
